import { NextResponse } from "next/server";
import { z } from "zod";
import { getQuote } from "@/lib/ai/quote";

// Minimal required inputs; others optional
const schema = z.object({
  service: z.string().min(2),
  rooms: z.number().int().positive().optional(),
  areaSqm: z.number().positive().optional(),
  quality: z.enum(["basic","standard","premium"]).optional(),
  postcode: z.string().optional(),
  notes: z.string().optional(),
});

// Simple deterministic fallback if AI/lib fails
function fallbackEstimate(input: {
  service: string;
  areaSqm?: number;
  rooms?: number;
  quality?: "basic" | "standard" | "premium";
}) {
  const qualityMul = input.quality === "premium" ? 1.3 : input.quality === "basic" ? 0.85 : 1.0;
  const area = Math.max(10, Math.min(300, Math.round(input.areaSqm ?? 25)));
  const rooms = Math.max(1, Math.min(6, Math.round(input.rooms ?? 1)));

  // Base rate by service (very rough)
  const basePerSqm: Record<string, number> = {
    "loft conversion": 1450,
    "extension": 1700,
    "refurbishment": 1200,
    "kitchen": 1400,
    "bathroom": 1600,
  };
  const key = input.service.toLowerCase();
  const rate = basePerSqm[key] ?? 1350;

  const mid = rate * area * qualityMul * (1 + (rooms - 1) * 0.08);
  const low = Math.round(mid * 0.9);
  const high = Math.round(mid * 1.15);
  return { low, high, currency: "GBP" as const };
}

export async function POST(req: Request) {
  const json = await req.json().catch(() => ({}));
  const parsed = schema.safeParse(json);
  if (!parsed.success) {
    return NextResponse.json(
      { ok: false, error: "Invalid payload", issues: parsed.error.format() },
      { status: 400 }
    );
  }

  const input = parsed.data;
  let quote;
  let usedAI = false;

  try {
    // Try AI/lib path first
    const q = await getQuote({
      service: input.service,
      rooms: input.rooms,
      areaSqm: input.areaSqm,
      quality: input.quality,
      postcode: input.postcode,
      notes: input.notes,
    });
    if (q?.low && q?.high) {
      quote = { low: Math.round(q.low), high: Math.round(q.high), currency: q.currency ?? "GBP" };
      usedAI = !!process.env.OPENAI_API_KEY;
    } else {
      quote = fallbackEstimate(input);
    }
  } catch {
    // Guaranteed fallback
    quote = fallbackEstimate(input);
  }

  return NextResponse.json({ ok: true, quote, usedAI });
}
