import { NextResponse } from "next/server";
import { z } from "zod";
import { PrismaClient, LeadStatus, Prisma, Urgency } from "@prisma/client";
import { getQuote } from "@/lib/ai/quote";

const db = new PrismaClient();

const LeadSchema = z.object({
  service: z.string().min(2),
  description: z.string().min(10),
  postcode: z.string().optional(),
  rooms: z.number().int().positive().optional(),
  areaSqm: z.number().positive().optional(),
  permissions: z.string().optional(),
  urgency: z.string().optional(),      // free-form from client; we will normalize
  budgetMin: z.number().int().nonnegative().optional(),
  budgetMax: z.number().int().nonnegative().optional(),
  timeline: z.string().optional(),
  name: z.string().optional(),
  email: z.string().email().optional(),
  phone: z.string().optional(),
  source: z.string().optional(),
});
type LeadInput = z.infer<typeof LeadSchema>;

async function deliverToWebhook(lead: any) {
  const url = process.env.SHEETS_WEBHOOK_URL;
  if (!url) return { ok: true, skipped: true };
  for (let i = 0; i < 3; i++) {
    try {
      const r = await fetch(url, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(lead),
      });
      if (r.ok) return { ok: true };
    } catch {}
    await new Promise((r) => setTimeout(r, 500 * (i + 1)));
  }
  return { ok: false };
}

// Normalize strings like "within_3_months" -> Urgency.WITHIN_3_MONTHS (if valid)
function toUrgency(v?: string | null): Urgency | null {
  if (!v) return null;
  const candidate = v.toUpperCase().replace(/[^A-Z0-9_]/g, "_");
  const allowed = Object.values(Urgency) as string[];
  return allowed.includes(candidate) ? (candidate as Urgency) : null;
}

export async function POST(req: Request) {
  const json = await req.json().catch(() => ({}));
  const parsed = LeadSchema.safeParse(json);
  if (!parsed.success) {
    return NextResponse.json(
      { ok: false, error: "Invalid payload", issues: parsed.error.format() },
      { status: 400 }
    );
  }

  const data = parsed.data;

  // Compute a quote snapshot (fallback if no OPENAI_API_KEY)
  const q = await getQuote({
    service: data.service,
    rooms: data.rooms,
    areaSqm: data.areaSqm,
    quality: "standard",
    postcode: data.postcode,
    notes: data.description,
  });
  const estimateLow = Math.round(q.low ?? 0);
  const estimateHigh = Math.round(q.high ?? 0);
  const currency = q.currency ?? "GBP";

  const baseCreate: Prisma.LeadCreateInput = {
    service: data.service,
    description: data.description,
    postcode: data.postcode ?? null,
    rooms: data.rooms ?? null,
    areaSqm: data.areaSqm ?? null,
    permissions: data.permissions ?? null,
    urgency: toUrgency(data.urgency),     // âœ… enum-safe
    budgetMin: data.budgetMin ?? null,
    budgetMax: data.budgetMax ?? null,
    timeline: data.timeline ?? null,
    name: data.name ?? null,
    email: data.email ? data.email.toLowerCase().trim() : null,
    phone: data.phone ?? null,
    source: data.source ?? "quote-wizard",
    status: LeadStatus.QUEUED,
  };

  let createdId: string | null = null;

  // Create; if unique-email collision, retry with email: null (helps repeated sanity runs)
  try {
    const created = await db.lead.create({ data: baseCreate });
    createdId = created.id;
  } catch (e: any) {
    if (e?.code === "P2002" && Array.isArray(e?.meta?.target) && e.meta.target.includes("email")) {
      const created = await db.lead.create({ data: { ...baseCreate, email: null } });
      createdId = created.id;
    } else {
      return NextResponse.json({ ok: false, error: "DB_CREATE_FAILED" }, { status: 500 });
    }
  }

  const delivery = createdId ? await deliverToWebhook({ id: createdId, ...data }) : { ok: false };
  if (createdId && delivery.ok) {
    await db.lead.update({
      where: { id: createdId },
      data: { status: LeadStatus.DELIVERED, deliveredAt: new Date() },
    });
  }

  return NextResponse.json({
    ok: true,
    id: createdId,
    estimate: { low: estimateLow, high: estimateHigh, currency },
    delivered: !!delivery.ok,
  });
}
